---- openpetra.js.before/csharp/ICT/Common/Remoting/Shared/Serialization.cs     2014-08-29 15:39:26.000000000 +0200
-+++ openpetra.js/csharp/ICT/Common/Remoting/Shared/Serialization.cs    2014-08-29 15:37:58.000000000 +0200
@@ -43,6 +43,11 @@
     /// TODO: rename the class
     public class THttpBinarySerializer
     {
+        static private bool isJSClient()
+        {
+            return HttpContext.Current!=null && !HttpContext.Current.Request.UserAgent.Contains("OpenPetra");
+        }
+
         static private string DataSetToJson(DataSet ADataset)
         {
             JavaScriptSerializer serializer = new JavaScriptSerializer();
@@ -99,10 +104,60 @@
         }
 
         /// <summary>
-        /// serialize any object. if it is a complex type, use JSON
+        /// serialize any object. if it is a complex type, use JSON or Base64 (fat client)
         /// </summary>
         static public string SerializeObject(object o, bool binary)
         {
+            return THttpBinarySerializer::isJSClient()? SerializeObjectJSON(o, binary): SerializeObjectBase64(o, binary);
+        }
+
+        /// <summary>
+        /// serialize any object. if it is a complex type, use Base64
+        /// </summary>
+        static public string SerializeObjectBase64(object o, bool binary)
+        {
+            if (!binary)
+            {
+                if (o.GetType() == typeof(bool))
+                {
+                    return o.ToString().ToLower();
+                }
+
+                return o.ToString();
+            }
+
+            if (o == null)
+            {
+                return "null";
+            }
+
+            MemoryStream memoryStream = new MemoryStream();
+            BinaryFormatter binaryFormatter = new BinaryFormatter();
+            try
+            {
+                binaryFormatter.Serialize(memoryStream, o);
+            }
+            catch (Exception e)
+            {
+                TLogging.Log("cannot serialize object of type " + o.GetType().ToString());
+
+                TLogging.Log(e.ToString());
+            }
+            string encoded = Convert.ToBase64String(memoryStream.ToArray()) + ":binary";
+
+            if (encoded.Length > 1024 * 1024 * 4)
+            {
+                TLogging.Log("Warning: THttpBinarySerializer.SerializeObject: Binary parameter is too long: " + encoded.Length.ToString());
+            }
+
+            return encoded;
+        }
+
+        /// <summary>
+        /// serialize any object. if it is a complex type, use JSON
+        /// </summary>
+        static public string SerializeObjectJSON(object o, bool binary)
+        {
             if (!binary)
             {
                 if (o.GetType() == typeof(bool))
@@ -209,12 +264,25 @@
 
             string result = SerializeObject(o, binary);
 
-            if ((result.Length > 0) && (result[0] != '{') && (result[0] != '['))
+            if (THttpBinarySerializer::isJSClient())
             {
-                result = "\"" + result + "\"";
-            }
+                if ((result.Length > 0) && (result[0] != '{') && (result[0] != '['))
+                {
+                    result = "\"" + result + "\"";
+                }
 
-            return result;
+                return result;
+            }
+            
+            // fat client
+            if (result.EndsWith(":binary"))
+            {
+                return result;
+            }
+            else
+            {
+                return result + ":" + (binary ? "binary" : o.GetType().ToString());
+            }
         }
 
         /// <summary>
